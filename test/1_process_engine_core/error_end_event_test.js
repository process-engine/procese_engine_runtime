'use strict';

const should = require('should');
const TestFixtureProver = require('../../dist/commonjs/test_setup').TestFixtureProvider;

describe('ErrorEndEvent - ', () => {

  let testFixtureProvider;

  const startEventId = 'StartEvent_1';
  const useAutoGeneratedCorrelationId = undefined;

  before(async () => {
    testFixtureProvider = new TestFixtureProver();
    await testFixtureProvider.initializeAndStart();

    const processDefFileList = [
      'error_end_event_test',
      'error_end_event_boundary_test',
      'error_end_event_subprocess_call_activity_test',
      'error_end_event_call_activity_called_process',
    ];
    await testFixtureProvider.importProcessFiles(processDefFileList);
  });

  after(async () => {
    await testFixtureProvider.tearDown();
  });

  it('should throw a defined error, when the ErrorEndEvent is reached', async () => {

    const processModelId = 'error_end_event_test';
    const initialToken = {
      errorToThrow: 'defined_error',
    };

    try {
      await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    } catch (error) {
      should(error.code).be.eql('expectedError');
      should(error.name).be.eql('Expected Error');
    }
  });

  it('should throw an anonymous error, when the ErrorEndEvent is reached', async () => {

    const processModelId = 'error_end_event_test';
    const initialToken = {
      errorToThrow: 'anonymous_error',
    };

    try {
      await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    } catch (error) {
      should(error.name).be.eql('');
      should(error.message).be.eql('');
      should(error.code).be.eql('');
    }
  });

  it('should throw an error, when the Error End Event followed a Boundary Event', async () => {

    const processModelId = 'error_end_event_boundary_test';

    try {
      await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, {});
    } catch (error) {
      console.log(error);
      should(error.name).be.equal('ErrorFromEndEvent');
      should(error.code).be.equal('666');
    }
  });

  it('should execute a call activity which ends with an ErrorEndEvent', async () => {

    const processModelId = 'error_end_event_subprocess_call_activity_test';

    const initialToken = {
      test_scenario: 'call_activity',
    };

    try {
      await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    } catch (error) {
      should(error.name).be.equal('ExpectedError');
      should(error.code).be.equal('ErrorCode');
    }
  });

  it('should execute a subprocess which ends with an ErrorEndEvent', async () => {

    const processModelId = 'error_end_event_subprocess_call_activity_test';

    const initialToken = {
      test_scenario: 'sub_process',
    };

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    const expectedResult = 'Error handled by sub process\'s error boundary event';

    should(result).have.property('currentToken');
    should(result.currentToken).have.property('current');
    should(result.currentToken.current).be.eql(expectedResult);
  });
});
